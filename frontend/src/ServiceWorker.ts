/// <reference lib="webworker" />
/// <reference path="./types/serviceWorkerTypes.ts" />
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
	CacheFirst,
	NetworkFirst,
	NetworkOnly,
	StaleWhileRevalidate,
} from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

// Use the precache manifest generated by VitePWA
precacheAndRoute(self.__WB_MANIFEST);

const API_VERSION = import.meta.env.VITE_API_VERSION;

// Authentication endpoints should NEVER be cached
registerRoute(
	({ url }) =>
		url.pathname.startsWith(`${API_VERSION}/auth/`) ||
		url.pathname.startsWith(`${API_VERSION}/users/email-verifications/`) ||
		url.pathname.startsWith(`${API_VERSION}/users/password-resets/`) ||
		url.pathname.startsWith(`${API_VERSION}/users/verification-status`) ||
		url.pathname.includes("verify-email") ||
		url.pathname.includes("send-verification"),
	new NetworkOnly(),
);

// Static reference data that changes rarely - can be cached aggressively
registerRoute(
	({ url }) =>
		url.pathname === `${API_VERSION}/families/botanical-groups/` ||
		(url.pathname.startsWith(`${API_VERSION}/families/`) &&
			!url.pathname.includes("user-specific")),
	new StaleWhileRevalidate({
		cacheName: "reference-data-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 50,
				maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
			}),
			new CacheableResponsePlugin({
				statuses: [0, 200],
			}),
		],
	}),
);

// User-specific data - short cache for offline functionality only
// React Query handles the real caching and invalidation
registerRoute(
	({ url }) =>
		url.pathname.startsWith(`${API_VERSION}/users/`) ||
		url.pathname.startsWith(`${API_VERSION}/grow-guides/`) ||
		url.pathname.startsWith(`${API_VERSION}/todos/`),
	new NetworkFirst({
		cacheName: "user-data-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 30,
				maxAgeSeconds: 60 * 5, // 5 minutes - very short for offline only
			}),
			new CacheableResponsePlugin({
				statuses: [0, 200],
			}),
		],
	}),
);

// Other API responses - minimal caching for offline support
registerRoute(
	({ url }) => url.pathname.startsWith(API_VERSION),
	new NetworkFirst({
		cacheName: "api-fallback-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 20,
				maxAgeSeconds: 60 * 2, // 2 minutes - minimal offline support
			}),
		],
	}),
);

// Static assets - can be cached aggressively
registerRoute(
	({ request }) =>
		request.destination === "image" ||
		request.destination === "style" ||
		request.destination === "script",
	new CacheFirst({
		cacheName: "static-assets-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 100,
				maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
			}),
		],
	}),
);

// Fonts - cache for a very long time
registerRoute(
	({ request }) => request.destination === "font",
	new CacheFirst({
		cacheName: "font-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 20,
				maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
			}),
		],
	}),
);

// Navigation fallback - serve app shell when offline
const navStrategy = new NetworkFirst({
	cacheName: "pages-cache",
	plugins: [
		new CacheableResponsePlugin({ statuses: [200] }),
		new ExpirationPlugin({ maxEntries: 10 }),
	],
});

registerRoute(
	({ request }) => request.mode === "navigate",
	async ({ request, event }) => {
		try {
			const response = await navStrategy.handle({ request, event });
			if (response) return response;

			// Fallback to app shell
			const index = await caches.match("/index.html");
			if (index) return index;

			return (
				(await caches.match("/offline.html")) ??
				new Response("Offline", { status: 503 })
			);
		} catch {
			return (
				(await caches.match("/offline.html")) ??
				new Response("Offline", { status: 503 })
			);
		}
	},
);

// Handle app updates
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

self.addEventListener("activate", (event) => {
	event.waitUntil(self.clients.claim());
});

// Install event - cache app shell
self.addEventListener("install", (event) => {
	self.skipWaiting();

	event.waitUntil(
		caches.open("app-shell-cache").then((cache) => {
			return cache.addAll([
				"/",
				"/index.html",
				"/offline.html",
				"/manifest.webmanifest",
			]);
		}),
	);
});
