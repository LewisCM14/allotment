/// <reference lib="webworker" />
/// <reference path="./types/serviceWorkerTypes.ts" />
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
	CacheFirst,
	NetworkFirst,
	NetworkOnly,
	StaleWhileRevalidate,
} from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

// Use the precache manifest generated by VitePWA
precacheAndRoute(self.__WB_MANIFEST);

// Authentication-related API calls should always go to the network
registerRoute(
	({ url }) =>
		url.pathname.includes("/auth/") ||
		url.pathname.includes("/send-verification-email") ||
		url.pathname.includes("/verify-email") ||
		url.pathname.includes("/verification-status"),
	new NetworkOnly(),
);

// User profile data
registerRoute(
	({ url }) => url.pathname.includes("/user/profile"),
	new StaleWhileRevalidate({
		cacheName: "user-data-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 10,
				maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
			}),
		],
	}),
);

// Other API responses with network-first strategy
registerRoute(
	({ url }) => url.pathname.startsWith("/api"),
	new NetworkFirst({
		cacheName: "api-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 50,
				maxAgeSeconds: 60 * 60 * 24, // 1 day
			}),
		],
	}),
);

// Cache assets
registerRoute(
	({ request }) =>
		request.destination === "image" || request.destination === "style",
	new CacheFirst({
		cacheName: "assets-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 60,
				maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
			}),
		],
	}),
);

// Static resources (scripts, styles)
registerRoute(
	({ request }) =>
		request.destination === "script" || request.destination === "style",
	new StaleWhileRevalidate({
		cacheName: "static-resources",
	}),
);

// Cache the fonts
registerRoute(
	({ request }) => request.destination === "font",
	new CacheFirst({
		cacheName: "font-cache",
		plugins: [
			new ExpirationPlugin({
				maxEntries: 10,
				maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
			}),
		],
	}),
);

// Fallback page for when offline and navigation fails
self.addEventListener("fetch", (event) => {
	if (event instanceof FetchEvent && event.request.mode === "navigate") {
		event.respondWith(
			fetch(event.request).catch(async () => {
				const cache = await caches.open("app-shell");
				const cachedResponse = await cache.match("/offline.html");
				return (
					cachedResponse ||
					new Response(
						`<!DOCTYPE html>
						<html lang="en">
						<head>
							<meta charset="UTF-8">
							<meta name="viewport" content="width=device-width, initial-scale=1.0">
							<title>Offline</title>
							<style>
								body {
									font-family: system-ui, -apple-system, sans-serif;
									display: flex;
									flex-direction: column;
									align-items: center;
									justify-content: center;
									min-height: 100vh;
									margin: 0;
									padding: 20px;
									text-align: center;
									background-color: #f9fafb;
									color: #1f2937;
								}
								.container {
									max-width: 500px;
								}
								h1 {
									color: #007333;
									margin-bottom: 1rem;
								}
								p {
									margin-bottom: 1.5rem;
									line-height: 1.5;
								}
								.icon {
									font-size: 64px;
									margin-bottom: 1rem;
								}
							</style>
						</head>
						<body>
							<div class="container">
								<div class="icon">ðŸŒ±</div>
								<h1>You're Offline</h1>
								<p>It looks like you don't have an internet connection right now. Some features may not be available.</p>
								<p>Please check your connection and try again.</p>
								<button onclick="window.location.reload()">Try Again</button>
							</div>
						</body>
						</html>`,
						{
							status: 503,
							statusText: "Service Unavailable",
							headers: new Headers({
								"Content-Type": "text/html",
							}),
						},
					)
				);
			}),
		);
	}
});

// Listen for message events - this allows communication with the main thread
self.addEventListener("message", (event) => {
	// Check if the message is about auth state
	if (event.data && event.data.type === "AUTH_STATE_CHANGE") {
		// Notify the main thread about the auth state change
		self.clients.matchAll({ includeUncontrolled: true }).then((clients) => {
			for (const client of clients) {
				client.postMessage({
					type: "AUTH_STATE_UPDATED",
					payload: event.data.payload,
				});
			}
		});
	}

	// Handle app update checks
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

// Cache the app shell for offline use
self.addEventListener("install", (event) => {
	const installEvent = event as ExtendableEvent;
	installEvent.waitUntil(
		caches.open("app-shell").then((cache) => {
			return cache.addAll([
				"/",
				"/index.html",
				"/offline.html",
				"/manifest.json",
			]);
		}),
	);
});
